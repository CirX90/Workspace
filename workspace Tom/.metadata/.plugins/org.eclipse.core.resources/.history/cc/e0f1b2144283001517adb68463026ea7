/**
 * Praktikum TI-PM2, WS 2015
 * Gruppe: Tom-Henrik Hertel (tom-henrik.hertel@haw-hamburg.de)
 * 		   Lenard Lange 	 (lenard.lange@haw-hamburg.de)
 * Aufgabe: Aufgabenblatt 1, Aufgabe 1.4
 * Verwendete Quellen: Vorlesungsfolien
 */

package aufgabenblatt1;

public class ArrayList<T> {

	/**
	 * Deklaration einer Ganzzahl Variabel.
	 */

	int anzahlElemente;

	/**
	 * Deklaration eines Object Arrays.
	 */

	private Object[] elemente;

	/**
	 * Konstruktor. Damit kann direkt die List-Groeße bestimmt werden.
	 * 
	 * @param groesse
	 */

	public ArrayList(int groesse) {
		elemente = new Object[groesse];
		anzahlElemente = 0;
	}

	/**
	 * Hinzufuegen von Elementen in die Liste. Dabei wird die Liste jeweils um
	 * eine Stelle verlängert.
	 * 
	 * @param element
	 */

	public void hinzufuegen(T element) {
		// nkb anzahlElemente und length auswerten
		// wenn nicht genug Platz dann Plätze verdoppeln
		// System.Arraycopy verwenden
		Object[] neuElementeArray = new Object[elemente.length + 1];
		for (int i = 0; i < elemente.length; i++) {
			neuElementeArray[i] = elemente[i];
		}

		anzahlElemente = neuElementeArray.length;
		neuElementeArray[elemente.length] = element;
		elemente = neuElementeArray;

	}

	/**
	 * Getter
	 * 
	 * @param index
	 * @return wenn nichts gefunden wird soll er Null zurueckgeben, ansonsten
	 *         gibt er das Element an dem angegebenen Index zurueck.
	 * 
	 */
	public T get(int index) {
		if (index < anzahlElemente && index >= 0) {
			return (T) elemente[index];
		} else {

			return null;
		}
	}

	/**
	 * Gewünschtes Element aus der Liste entfernen.
	 * 
	 * @param element
	 *            welches entfernt werden soll
	 */
	public void entfernen(T element) {
		// nkb Leere Plätze in der Mitte sollen nicht vorhanden sein
		if (anzahlElemente != 0) {

			for (int i = 0; i < anzahlElemente; i++) {
				if (elemente[i].equals(element)) {
					elemente[i] = null;
					// for schleife
					for (int j = i; j < anzahlElemente-1; j++) {
						elemente[j] = elemente[j+1];
						
						
						
	//					if (elemente[j] == null) {
	//						elemente[j] = elemente[j + 1];
	//						elemente[anzahlElemente - 1] = null;
						}
	//				elemente[anzahlElemente-1] = null;

						// elemente[i+1] = elemente[i];
						// elemente[anzahlElemente-1] = null;

					}
				}
			}
		}
	

	/**
	 * Element an gewünschtem Index entfernen, falls Index ungültig ist wird die
	 * Exception gefangen.
	 * 
	 * @param index
	 */
	public void entferneElementAnIndex(int index) {

		// nkb Lösung laut get nehmen (if ....)
		if (index < anzahlElemente && index >= 0) {
			elemente[index] = null;

		}

	}

	/**
	 * 
	 * Getter Ausgabe der Anzahl
	 * 
	 * @return anzahlElemente
	 */

	public int getAnzahlElemente() {
		return anzahlElemente;
	}

	/**
	 * Methode um die Ausgabe zu formatieren.
	 */

	public String toString() {
		String ausgabe = "";
		for (int i = 0; i < anzahlElemente; i++) {
			ausgabe += elemente[i];
		}
		return ausgabe;

	}

	/**
	 * Die Elemente werden miteinander verglichen und das Kleinste wird
	 * zurückgegeben.
	 * 
	 * @return (T) ergebnis
	 */

	public <T extends Comparable<T>> T getKleinstesElement() {
		T ergebnis = (T) elemente[0];
		int i = 0;
		while (i < elemente.length) {
			T original = (T) elemente[i];
			// nkb < -1
			if (original.compareTo(ergebnis) < 0) {
				ergebnis = (T) elemente[i];
			}
			i++;
		}
		return ergebnis;

	}

	/**
	 * Wenn Zahlen enthalten sind, dann werden diese zusammengerechnet,
	 * ansonsten wird 0 zurueckgegeben.
	 * 
	 * @return result
	 */

	public int summenRechner() {

		int result = 0;

		if (!(elemente[0] instanceof Integer)) {
			return 0;
		}

		for (int i = 0; i < anzahlElemente; i++) {
			result += (int) elemente[i];
		}

		return result;
	}
}